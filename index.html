<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMWK 6: Proof and Implementation</title>
    
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load Tailwind Typography for article styling -->
    <script src="https://cdn.tailwindcss.com/3.4.1?plugins=typography"></script>
    
    <!-- 3. Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- 4. Configure MathJax to recognize $ and $$ delimiters -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    
    <!-- 5. Load MathJax to render LaTeX formulas -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Use a subtle gradient for a more modern feel */
            background-color: #f8fafc; /* fallback */
            background-image: linear-gradient(135deg, #f8fafc 0%, #eef2ff 100%);
        }
        
        /* Custom focus ring for calculator */
        .focus-ring:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4);
        }

        /* Button hover effect */
        .btn-hover {
            transition: all 0.2s ease-in-out;
        }
        .btn-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        /* Article styling adjustments */
        .prose h1 {
            background-image: linear-gradient(120deg, #6366f1, #a855f7);
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
        }

        .prose h2 {
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 8px;
        }

        .prose ol > li::before {
            color: #6366f1; /* Indigo color for numbers */
        }
    </style>
</head>
<body class="py-12 px-4">

    <!-- Main Page Container -->
    <main class="max-w-4xl mx-auto bg-white p-8 sm:p-12 rounded-2xl shadow-xl">
        
        <!-- Article Content - Styled with Tailwind Typography 'prose' -->
        <article class="prose prose-lg max-w-none">
            
            <h1>HMWK 6: The Online Way to Calculate Mean and Variance</h1>

            <!-- Section 1: Introduction -->
            <h2>1. Why Online Algorithms?</h2>
            
            <p>We all learn the normal way to find the mean or average of a dataset in school: add up all the numbers, then divide by how many numbers you have. Simple, right?</p>
            <p>Thats great for a homework problem with 10 numbers. But what about the real world? What if your dataset is a live feed of stock prices? What if its the clickstream from a website, generating thousands of data points every second? You cant just wait until its all there, and you definitely dont want to re-calculate the entire sum every time a new number comes in. Your computer would melt!</p>
            <p>This is the exact problem online algorithms solve. Theyre a clever way to update statistics one data point at a time, using only the previous statistical values and the new data point. Its the perfect tool for streaming data, massive datasets, or any dashboard that needs to stay up-to-the-second.</p>
            <p>So, lets roll up our sleeves and see how to build these for the two most important statistics: mean and variance.</p>

            <!-- Section 2: Mean -->
            <h2>2. Part 1: The Shortcut for the Mean</h2>
            
            <h3>Standard (Batch) Formula</h3>
            <p>As a quick reminder, the batch formula for the mean ($\bar{x}$) of $n$ numbers is:</p>
            $$ \bar{x}_n = \frac{1}{n} \sum_{i=1}^{n} x_i $$

            <h3>Derivation of the Recurrence Formula</h3>
            <p>Lets put on our algebra hats for a minute. This isnt just for fun—our goal is to find a shortcut that lets us calculate the new mean ($\bar{x}_n$) using only the old mean ($\bar{x}_{n-1}$) and the new number ($x_n$). No more re-summing everything!</p>
            <ol>
                <li>We start with the basic, textbook definition for $n$ items:
                   $$ \bar{x}_n = \frac{1}{n} \sum_{i=1}^{n} x_i $$
                </li>
                <li>Lets break that sum apart into everything we had before and the new number:
                   $$ \bar{x}_n = \frac{1}{n} \left( \left( \sum_{i=1}^{n-1} x_i \right) + x_n \right) $$
                </li>
                <li>This is the key trick. We know that the sum of the first $n-1$ items is just the old mean times $n-1$. (Since $\bar{x}_{n-1} = \frac{\sum_{i=1}^{n-1} x_i}{n-1}$, just multiply both sides by $n-1$). Lets substitute that in:
                   $$ \bar{x}_n = \frac{1}{n} \left( (n-1) \bar{x}_{n-1} + x_n \right) $$
                </li>
                <li>This formula works! Its correct. But we can make it much more intuitive. Lets do a little algebraic shuffle to see whats really happening—how the mean changes:
                   $$ \bar{x}_n = \frac{1}{n} \left( (n \bar{x}_{n-1} - \bar{x}_{n-1}) + x_n \right) $$
                   $$ \bar{x}_n = \frac{1}{n} \left( n \bar{x}_{n-1} + (x_n - \bar{x}_{n-1}) \right) $$
                   $$ \bar{x}_n = \bar{x}_{n-1} + \frac{1}{n} (x_n - \bar{x}_{n-1}) $$
                </li>
            </ol>

            <h3>The Online Mean Algorithm</h3>
            <p>And there it is! That final formula is beautiful, isnt it? It reads, in plain English:</p>
            <p>The new mean is just the old mean, plus a small nudge.</p>
            <p>That nudge is simply the difference or error between the new number and the old mean, scaled down by how many numbers we have. Simple, fast, and elegant.</p>
            <ul>
                <li><strong>Initialization:</strong> $\bar{x}_0 = 0$, $n = 0$</li>
                <li><strong>For each new data point</strong> $x$:
                    <ul>
                        <li>$n = n + 1$</li>
                        <li>$\bar{x}_n = \bar{x}_{n-1} + \frac{1}{n} (x - \bar{x}_{n-1})$</li>
                    </ul>
                </li>
            </ul>

            <!-- Section 3: Variance -->
            <h2>3. Part 2: Taming the Variance (Welfords Algorithm)</h2>
            <p>Okay, brace yourself. Deriving the online formula for variance is a bit of a beast, and the math looks scarier than it is. But the final result is just as elegant as the one for the mean. This method is famously stable and efficient, known as Welfords algorithm.</p>

            <h3>Standard (Batch) Formula</h3>
            <p>The standard formula for the <em>sample variance</em> ($s^2$) is:</p>
            $$ s_n^2 = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x}_n)^2 $$
            <p>The tricky part is that $\sum (x_i - \bar{x}_n)^2$ term, which is the sum of squared differences. Lets call it $M_{2,n}$. We need to find a recurrence for $M_{2,n}$.</p>

            <h3>Derivation of the Recurrence Formula (Welford)</h3>
            <p>This derivation is more involved, but its a classic proof in computational statistics. The goal is the same as before: express the new sum-of-squares ($M_{2,n}$) using only the old sum-of-squares ($M_{2, n-1}$) and our new/old means. No storing all the data!</p>
            <ol>
                <li>Lets define a delta as the difference between the new point and the <em>old</em> mean:
                    <ul>
                        <li>$\delta = x_n - \bar{x}_{n-1}$</li>
                    </ul>
                </li>
                <li>We also know from our mean algorithm that $\bar{x}_n = \bar{x}_{n-1} + \frac{\delta}{n}$.</li>
                <li>Lets look at the term $(x_n - \bar{x}_n)$:
                    <ul>
                        <li>$x_n - \bar{x}_n = (x_n - \bar{x}_{n-1}) - (\bar{x}_n - \bar{x}_{n-1}) = \delta - \frac{\delta}{n} = \delta \left(\frac{n-1}{n}\right)$</li>
                    </ul>
                </li>
                <li>And the term for all other points ($i < n$):
                    <ul>
                        <li>$x_i - \bar{x}_n = (x_i - \bar{x}_{n-1}) - (\bar{x}_n - \bar{x}_{n-1}) = (x_i - \bar{x}_{n-1}) - \frac{\delta}{n}$</li>
                    </ul>
                </li>
                <li>Now for the big step. Well substitute (3) and (4) into the definition of $M_{2,n}$.
                    <ul>
                        <li>$M_{2,n} = \sum_{i=1}^{n-1} (x_i - \bar{x}_n)^2 + (x_n - \bar{x}_n)^2$</li>
                        <li>$M_{2,n} = \sum_{i=1}^{n-1} \left( (x_i - \bar{x}_{n-1}) - \frac{\delta}{n} \right)^2 + \left( \delta \frac{n-1}{n} \right)^2$</li>
                    </ul>
                </li>
                <li>Expand the squared binomial in the summation:
                    <ul>
                        <li>$\sum_{i=1}^{n-1} \left[ (x_i - \bar{x}_{n-1})^2 - 2 \frac{\delta}{n}(x_i - \bar{x}_{n-1}) + \left(\frac{\delta}{n}\right)^2 \right] + \delta^2 \frac{(n-1)^2}{n^2}$</li>
                    </ul>
                </li>
                <li>Distribute the summation. This is where the magic happens, and all the messy parts start to simplify beautifully:
                    <ul>
                        <li>The first term, $\sum (x_i - \bar{x}_{n-1})^2$, is just the definition of our old sum of squares, $M_{2, n-1}$.</li>
                        <li>The second term, $\sum 2 \frac{\delta}{n}(x_i - \bar{x}_{n-1})$, has a secret weapon. The $\sum(x_i - \bar{x}_{n-1})$ part is the sum of deviations from the old mean, which... is always <strong>zero</strong> by the very definition of a mean! So, this whole messy-looking term just vanishes. Gone.</li>
                        <li>The third term, $\sum (\frac{\delta}{n})^2$, is just adding that same constant value $n-1$ times. So it becomes $(n-1) (\frac{\delta}{n})^2$.</li>
                    </ul>
                </li>
                <li>Lets put it all back together:
                    <ul>
                        <li>$M_{2,n} = M_{2, n-1} + (n-1)\frac{\delta^2}{n^2} + \frac{(n-1)^2\delta^2}{n^2}$</li>
                        <li>$M_{2,n} = M_{2, n-1} + \frac{\delta^2 (n-1)}{n^2} (1 + (n-1))$</li>
                        <li>$M_{2,n} = M_{2, n-1} + \frac{\delta^2 (n-1)}{n^2} (n)$</li>
                        <li>$M_{2,n} = M_{2, n-1} + \delta^2 \frac{n-1}{n}$</li>
                    </ul>
                </li>
                <li>This is correct... but Welford found an even simpler, more beautiful form. Notice that $\delta^2 \frac{n-1}{n} = \delta \times (\delta \frac{n-1}{n})$. From step 3, we already know that $\delta \frac{n-1}{n} = (x_n - \bar{x}_n)$.
                    <ul>
                        <li>So, the whole update term $\delta \times (\delta \frac{n-1}{n})$ just becomes $\delta \times (x_n - \bar{x}_n)$, which is $(x_n - \bar{x}_{n-1})(x_n - \bar{x}_n)$.</li>
                        <li>$M_{2,n} = M_{2, n-1} + (x_n - \bar{x}_{n-1})(x_n - \bar{x}_n)$</li>
                    </ul>
                </li>
            </ol>
            
            <h3>The Online Variance Algorithm (Welford)</h3>
            <p>This final formula is stunning. To update the sum of squares ($M_2$), you just add the product of the old delta (new point vs. old mean) and the new delta (new point vs. new mean). No matter how many data points you have, the calculation is just a few simple steps.</p>
            <ul>
                <li><strong>Initialization:</strong> $n=0$, $\bar{x}=0$, $M_2=0$</li>
                <li><strong>For each new data point</strong> $x$:
                    <ul>
                        <li>$n = n + 1$</li>
                        <li>$\delta = x - \bar{x}$ (Old delta)</li>
                        <li>$\bar{x} = \bar{x} + \frac{\delta}{n}$ (New mean)</li>
                        <li>$\delta_2 = x - \bar{x}$ (New delta)</li>
                        <li>$M_2 = M_2 + \delta \times \delta_2$</li>
                    </ul>
                </li>
                <li><strong>Output:</strong>
                    <ul>
                        <li><strong>Mean:</strong> $\bar{x}$</li>
                        <li><strong>Sample Variance:</strong> $s^2 = M_2 / (n-1)$ (for $n > 1$)</li>
                    </ul>
                </li>
            </ul>

        </article>
        
        <!-- Divider -->
        <hr class="my-12 border-t border-gray-200">

        <!-- Implementation Section -->
        <div>
            <h2 class="text-3xl font-bold mb-6 text-gray-800">4. Implementation: Try It Yourself!</h2>
            <p class="text-lg text-gray-600 mb-8">Theory is great, but lets see it in action. The calculator below runs this exact Welfords algorithm. Go ahead and add some numbers—10, 100, 1000... watch the stats update instantly, no matter how many you add.</p>
            
            <div class="bg-white border border-gray-200 rounded-xl shadow-inner p-6 sm:p-8">
                <!-- Input Section -->
                <div class="flex flex-col sm:flex-row sm:space-x-3">
                    <input type="number" id="data-input" placeholder="Enter a number" class="flex-1 p-3 border border-gray-300 rounded-lg focus-ring text-lg mb-3 sm:mb-0">
                    <button id="add-button" class="btn-hover bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 flex items-center justify-center space-x-2">
                        <!-- Add Icon SVG -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                        <span>Add</span>
                    </button>
                </div>

                <!-- Statistics Display -->
                <div class="space-y-4 mt-6">
                    <!-- Count -->
                    <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <span class="text-lg font-medium text-gray-700">Count (n)</span>
                        <span id="count" class="text-lg font-bold text-gray-900 stat-value tabular-nums">0</span>
                    </div>
                    <!-- Mean -->
                    <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <span class="text-lg font-medium text-gray-700">Mean (x̄)</span>
                        <span id="mean" class="text-lg font-bold text-gray-900 stat-value tabular-nums">N/A</span>
                    </div>
                    <!-- Sample Variance -->
                    <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <span class="text-lg font-medium text-gray-700">Sample Variance (s²)</span>
                        <span id="variance" class="text-lg font-bold text-gray-900 stat-value tabular-nums">N/A</span>
                    </div>
                    <!-- Sample Standard Deviation -->
                    <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <span class="text-lg font-medium text-gray-700">Sample Std. Dev. (s)</span>
                        <span id="stdev" class="text-lg font-bold text-gray-900 stat-value tabular-nums">N/A</span>
                    </div>
                </div>

                <!-- Reset Button -->
                <div class="mt-8">
                    <button id="reset-button" class="btn-hover w-full bg-red-500 text-white px-6 py-3 rounded-lg font-semibold shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 flex items-center justify-center space-x-2">
                        <!-- Reset Icon SVG -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                        <span>Reset</span>
                    </button>
                </div>
            </div>
        </div>

    </main>

    <!-- Calculator JavaScript -->
    <script>
        // Wrap all code in an IIFE (Immediately Invoked Function Expression)
        (function() {
            // State variables
            let n = 0;
            let mean = 0;
            let M2 = 0; // Sum of squared differences from the mean

            // DOM Elements
            const dataInput = document.getElementById('data-input');
            const addButton = document.getElementById('add-button');
            const resetButton = document.getElementById('reset-button');
            
            const countSpan = document.getElementById('count');
            const meanSpan = document.getElementById('mean');
            const varianceSpan = document.getElementById('variance');
            const stdevSpan = document.getElementById('stdev');

            // Function to add a number
            function addNumber() {
                const valueStr = dataInput.value;
                if (valueStr === '') return;
                
                const newValue = parseFloat(valueStr);
                if (isNaN(newValue)) {
                    console.error('Please enter a valid number.');
                    dataInput.value = '';
                    return;
                }

                // --- Welford's Online Algorithm ---
                n++;
                const delta = newValue - mean;
                mean += delta / n;
                const delta2 = newValue - mean;
                M2 += delta * delta2;
                // --- End of Algorithm ---

                updateDisplay();

                dataInput.value = '';
                dataInput.focus();
            }

            // Function to update the HTML display
            function updateDisplay() {
                countSpan.textContent = n;
                meanSpan.textContent = mean.toFixed(4);

                if (n < 2) {
                    varianceSpan.textContent = 'N/A (need >1 data point)';
                    stdevSpan.textContent = 'N/A (need >1 data point)';
                } else {
                    const sampleVariance = M2 / (n - 1);
                    const sampleStdev = Math.sqrt(sampleVariance);
                    
                    varianceSpan.textContent = sampleVariance.toFixed(4);
                    stdevSpan.textContent = sampleStdev.toFixed(4);
                }
            }

            // Function to reset the calculator
            function resetCalculator() {
                n = 0;
                mean = 0;
                M2 = 0;
                
                countSpan.textContent = '0';
                meanSpan.textContent = 'N/A';
                varianceSpan.textContent = 'N/A';
                stdevSpan.textContent = 'N/A';
                
                dataInput.value = '';
                dataInput.focus();
            }

            // Event Listeners
            addButton.addEventListener('click', addNumber);
            resetButton.addEventListener('click', resetCalculator);
            
            dataInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    addNumber();
                }
            });
        })(); // End of IIFE
    </script>

</body>
</html>